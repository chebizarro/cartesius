<?php

class WebApiAdapter {

	protected static $connections = null;
	
	protected static $models = array();

	public static function configure($connections) {
		self::$connections = $connections;
	}

	public static function load_models($basepath) {
		$sql = "SELECT table_name FROM information_schema.tables WHERE table_type = 'BASE TABLE' AND table_schema NOT IN ('pg_catalog', 'information_schema');";

		foreach(self::$connections as $connection) {
			$tables = XMLORM::for_table('information_schema', $connection)->raw_query($sql)->use_id_column('table_name')->find_many()->as_array();
			foreach($tables as $key => $value) {
				$model_name = preg_replace('/(?:^|_)(.?)/e',"strtoupper('$1')",$key);
				$file_name = $basepath.$connection.'/'.$model_name.".php";
				if(file_exists($file_name)) {
					require_once($file_name);
				} else {
					file_put_contents($file_name, "<?php\n\n\nclass ".$model_name." extends XMLModel\n{\n\n}\n");
					require_once($file_name);
				}
				self::$models[$model_name] = $connection;
			}
		}
	}


	public static function show_metadata() {
		
		$metadata = array("dataServices" => [
						array(	"serviceName" => "/data/",
								"hasServerMetadata" => true,
								"jsonResultsAdapter" => "webApi_default",
								"useJsonp" => false ) ],
								"structuralTypes" => []);

		$resourceEntityTypeMap = [];

		foreach(get_declared_classes() as $model) {
			if (is_subclass_of($model, 'XMLModel')){
				$met = self::get_metadata($model);
				array_push($metadata["structuralTypes"], $met);
				$resourceEntityTypeMap[$met["defaultResourceName"]] = $met["shortName"] . ":#" . $met["namespace"];
			}
		}
		
		$metadata["resourceEntityTypeMap"] = $resourceEntityTypeMap;
		
		return $metadata;
	}


	private static function get_metadata($model) {
				
		$metadata = array(	"shortName" => $model,
							"namespace" => "XMLPARIS.Model",
							"autoGeneratedKeyType" => "Identity",
							"defaultResourceName" => $model,
							"dataProperties" => []
						);

		$tableName = preg_replace('/(?:^|_)(.?)/e',"strtoupper('$1')",$key);

		$sql = 'SELECT column_name AS name, is_nullable AS "isNullable", udt_name AS "dataType", column_default AS "defaultValue", character_maximum_length as "maxLength" FROM information_schema.columns WHERE table_name = \'' . $tableName  ."' ORDER BY ordinal_position";
		$keySql = 'SELECT column_name FROM information_schema.key_column_usage WHERE table_name = \''  . $tableName  ."'";
		
		$db = XMLORM::get_db(self::$models[$model]);
		$result = $db->query($sql)->fetchAll(PDO::FETCH_ASSOC);
		$keyResult = $db->query($keySql)->fetchAll(PDO::FETCH_ASSOC);
		
		$key = $keyResult[0]["column_name"];
		
		foreach ($result as $row) {
			$row["isNullable"] = ($row["isNullable"] == "YES" ? true : false);
			
			if($row["defaultValue"] == null) {
				unset($row["defaultValue"]);
			}
			
			if ($row["name"] == $key) {
				$row["isPartOfKey"] = true;
				unset($row["defaultValue"]);
			}
			
			if ($row["maxLength"] == null) {
				unset($row["maxLength"]);
			}
			
			array_push($metadata["dataProperties"], $row);
		}			

		$fkeySql = "SELECT
					tc.table_name, kcu.column_name,
					ccu.table_name AS foreign_table_name,
					ccu.column_name AS foreign_column_name,
					tc.constraint_name
					FROM
					information_schema.table_constraints AS tc
					JOIN information_schema.key_column_usage
					AS kcu ON tc.constraint_name = kcu.constraint_name
					JOIN information_schema.constraint_column_usage 
					AS ccu ON ccu.constraint_name = tc.constraint_name
					WHERE constraint_type = 'FOREIGN KEY'
					AND (ccu.table_name = '$tableName' OR tc.table_name = '$tableName');";
		
		$fkeyResult = $db->query($fkeySql)->fetchAll(PDO::FETCH_ASSOC);

		if(sizeof($fkeyResult) > 0) {
			
			$metadata["navigationProperties"] = [];

			foreach ($fkeyResult as $row) {
				$nav = [];
				
				if($row["table_name"] != $tableName) {
					$nav["name"] = $row["table_name"];
					$nav["entityTypeName"] = preg_replace('/(?:^|_)(.?)/e',"strtoupper('$1')",$row["table_name"]).":#XMLPARIS.Model";
					$nav["isScalar"] = true;
					$nav["associationName"] = $row["constraint_name"];
					$nav["foreignKeyNames"] = [$row["foreign_column_name"]];
					
				} else {
					$nav["name"] = $row["foreign_table_name"];
					$nav["entityTypeName"] = preg_replace('/(?:^|_)(.?)/e',"strtoupper('$1')",$row["foreign_table_name"]).":#XMLPARIS.Model";
					$nav["isScalar"] = false;						
					$nav["associationName"] = $row["constraint_name"];
					$nav["invForeignKeyNames"] = [$row["column_name"]];
				}
				array_push($metadata["navigationProperties"], $nav);
			}				
		}
		return $metadata;
	}


	public static function save_changes($data) {
		
	/*
	{
		"entities":[
			{
				"id":"K_-1",
				"title":"Test",
				"date":"",
				"review_date":"Thu Nov 21 2013 00:00:00 GMT+0700 (WIB)",
				"summary":null,
				"entityAspect":{
					"entityTypeName":"Project:#XMLPARIS.Model",
					"defaultResourceName":"Project",
					"entityState":"Added",
					"originalValuesMap":{},
					"autoGeneratedKey":{
						"propertyName":"id",
						"autoGeneratedKeyType":"Identity"
					}
				}
			}
		],
		"saveOptions":{}
	}
	*/

		foreach ($DATA->entities as $entity) {
			$aspect = $entity->entityAspect;
			if($aspect->entityState == "Added") {
				$model = XMLModel::factory($aspect->defaultResourceName, self::$models[$aspect->defaultResourceName])->create();
				$keyVar = $aspect->autoGeneratedKey->propertyName;
				foreach($entity as $key => $value) {
					if (($key !== $keyVar) && ($key !== "entityAspect")) {
						if(strtotime($value) != null) {
							$value = strtotime($value);
						}
						$model->$key = $value;
					}
				}
				$model->save();
			}
		}
	}


	function data($model, $vars) {
		//$allvars = $app->request->get();
		//print_r($allvars);
		
		//$inlinecount=allpages
		//$filter=(startswith(CompanyName,'S') eq true) and (substringof('er', City) eq true)
		//$orderby=UnitPrice desc,ProductName
		
	/*
		if(mb_substr($model, -3) == "ies") {
			$model = mb_substr($model, 0, (mb_strlen($model)-3)) . "y";
		} else {
			$model = mb_substr($model, 0, (mb_strlen($model)-1));
		}
	*/

		$data = XMLModel::factory($model, self::$models[$model]);

		$filter = $app->request->get('$filter');

		if($filter) {
			preg_match('/(.*?)\((.*?)\)\s([^\s]*)\s([^\s]*)/', $filter, $match);

			if(sizeof($match) > 0) {
				preg_match("/(.*),'(.*)'/", $match[2], $condition);
				switch ($match[1])
				{
					case "startswith":
						$condition[2] = $condition[2] . "%";
						break;
					case "endswith":
						$condition[2] = "%" . $condition[2];
						break;				
					case "contains":
					case "substringof":
						$condition[2] = "%" . $condition[2] . "%";
						break;
				}
				if ($match[4] == "true") {
					$data = $data->where_like($condition[1], $condition[2]);
				} else {
					$data = $data->where_not_like($condition[1], $condition[2]);				
				}
			} else {
				preg_match('/(.*)\s(.*)\s(.*)/', $filter, $match);
				$column = $match[1];
				$condition = $match[2];
				$value = $match[3];
				
				switch ($condition)
				{
					case "gt":
						$data = $data->where_gt($column, $value);
						break;
					case "lt":
						$data = $data->where_lt($column, $value);
						break;				
					case "eq":
						$data = $data->where_equal($column, $value);				
						break;
					case "ge":
						$data = $data->where_gte($column, $value);
						break;
					case "le":
						$data = $data->where_lte($column, $value);
						break;
					case "ne":
						$data = $data->where_not_equal($column, $value);
						break;	
				}
			}
		}
		
		$top = $app->request->get('$top');
		if ($top) {
			$data = $data->limit($top);
		}
		
		$skip = $app->request->get('$skip');
		if ($skip) {
			$data = $data->offset($skip);
		} 
	/*
		$orderby = $app->request->get('$orderby');
		$orderbyArray = explode(" ", $orderby);
		
		if (sizeof($orderbyArray) > 1) {
			$data = $data->order_by_desc($orderbyArray[0]);	
		} else {
			$data = $data->order_by_asc($orderbyArray[0]);	
		}
	*/
		return $data->find_many()->as_json();
		
	}

}
